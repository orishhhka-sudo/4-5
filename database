// lib/services/database_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../models/service.dart';
import '../models/ticket.dart';
import '../models/passport.dart';
import '../models/resident.dart';

class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  late DatabaseFactory _dbFactory;
  Database? _db;
  String _dbPath = '';

  Future<void> init({String? filePath}) async {
    sqfliteFfiInit();
    _dbFactory = databaseFactoryFfi;

    final dbFile = filePath ?? p.join(Directory.current.path, 'zhes.db');
    _dbPath = dbFile;

    print('DatabaseService.init() — DB path: $_dbPath');

    _db = await _dbFactory.openDatabase(
      dbFile,
      options: OpenDatabaseOptions(
        version: 1,
        onCreate: (db, version) async {
          await _createTables(db);
        },
      ),
    );

    await _createTables(_db!);
  }

  Future<void> close() async {
    await _db?.close();
    _db = null;
  }

  Future<void> _createTables(Database db) async {
    await db.execute('''
      CREATE TABLE IF NOT EXISTS services(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        price REAL NOT NULL,
        is_benefit INTEGER NOT NULL DEFAULT 0,
        discount_percent REAL
      );
    ''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS passports(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        series TEXT NOT NULL,
        number TEXT NOT NULL,
        full_name TEXT NOT NULL
      );
    ''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS residents(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        passport_id INTEGER NOT NULL,
        has_benefits INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY(passport_id) REFERENCES passports(id)
      );
    ''');

    await db.execute('''
      CREATE TABLE IF NOT EXISTS usages(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        resident_id INTEGER NOT NULL,
        service_id INTEGER NOT NULL,
        date TEXT NOT NULL,
        FOREIGN KEY(resident_id) REFERENCES residents(id),
        FOREIGN KEY(service_id) REFERENCES services(id)
      );
    ''');
  }

  // ----- Service CRUD -----
  Future<int> insertService(Service s) async {
    final db = _db!;
    return await db.insert('services', {
      'name': s.name,
      'price': s.price,
      'is_benefit': s is BenefitService ? 1 : 0,
      'discount_percent':
          s is BenefitService ? (s as BenefitService).discountPercent : null,
    });
  }

  Future<List<Service>> getAllServices() async {
    final db = _db!;
    final rows = await db.query('services');
    return rows.map((r) {
      final isBenefit = (r['is_benefit'] as int) == 1;
      if (isBenefit) {
        return BenefitService(
          name: r['name'] as String,
          price: (r['price'] as num).toDouble(),
          discountPercent: (r['discount_percent'] as num).toDouble(),
        );
      }
      return Service(
        name: r['name'] as String,
        price: (r['price'] as num).toDouble(),
      );
    }).toList();
  }

  // ----- Passport helper -----
  Future<int> _ensurePassport(Passport psp) async {
    final db = _db!;
    final rows = await db.query(
      'passports',
      where: 'series = ? AND number = ?',
      whereArgs: [psp.series, psp.number],
      limit: 1,
    );
    if (rows.isNotEmpty) return rows.first['id'] as int;

    return await db.insert('passports', {
      'series': psp.series,
      'number': psp.number,
      'full_name': psp.fullName,
    });
  }

  // ----- Resident helper -----
  Future<int> _ensureResident(Resident r) async {
    final db = _db!;
    final passportId = await _ensurePassport(r.passport);

    final rows = await db.query(
      'residents',
      where: 'passport_id = ?',
      whereArgs: [passportId],
      limit: 1,
    );

    if (rows.isNotEmpty) {
      // если статус льготы поменялся — обновим
      final rid = rows.first['id'] as int;
      await db.update(
        'residents',
        {'has_benefits': r.hasBenefits ? 1 : 0},
        where: 'id = ?',
        whereArgs: [rid],
      );
      return rid;
    }

    return await db.insert('residents', {
      'passport_id': passportId,
      'has_benefits': r.hasBenefits ? 1 : 0,
    });
  }

  // ----- Usage duplicate check -----
  Future<int?> _findExistingUsageId(Ticket t) async {
    final db = _db!;
    final rows = await db.rawQuery('''
      SELECT u.id as uid
      FROM usages u
      JOIN residents r ON u.resident_id = r.id
      JOIN passports p ON r.passport_id = p.id
      JOIN services s ON u.service_id = s.id
      WHERE p.series = ? AND p.number = ? AND s.name = ? AND u.date = ?
      LIMIT 1
    ''', [
      t.resident.passport.series,
      t.resident.passport.number,
      t.service.name,
      t.date
    ]);

    if (rows.isNotEmpty) return rows.first['uid'] as int;
    return null;
  }

  Future<int> insertTicket(Ticket t) async {
    final db = _db!;
    final existingId = await _findExistingUsageId(t);
    if (existingId != null) return existingId;

    final residentId = await _ensureResident(t.resident);

    // service by name+price
    final serviceRow = await db.query(
      'services',
      where: 'name = ? AND price = ?',
      whereArgs: [t.service.name, t.service.price],
      limit: 1,
    );
    int serviceId;
    if (serviceRow.isEmpty) {
      serviceId = await insertService(t.service);
    } else {
      serviceId = serviceRow.first['id'] as int;
    }

    return await db.insert('usages', {
      'resident_id': residentId,
      'service_id': serviceId,
      'date': t.date,
    });
  }

  Future<List<Ticket>> getAllTickets() async {
    final db = _db!;
    final rows = await db.rawQuery('''
      SELECT u.id as uid, u.date,
             p.series, p.number, p.full_name,
             r.has_benefits,
             s.name as sname, s.price as sprice, s.is_benefit, s.discount_percent
      FROM usages u
      JOIN residents r ON u.resident_id = r.id
      JOIN passports p ON r.passport_id = p.id
      JOIN services s ON u.service_id = s.id
      ORDER BY u.id ASC
    ''');

    return rows.map((r) {
      final passport = Passport(
        series: r['series'] as String,
        number: r['number'] as String,
        fullName: r['full_name'] as String,
      );

      final resident = Resident(
        passport: passport,
        hasBenefits: (r['has_benefits'] as int) == 1,
      );

      final isBenefitService = (r['is_benefit'] as int) == 1;
      final service = isBenefitService
          ? BenefitService(
              name: r['sname'] as String,
              price: (r['sprice'] as num).toDouble(),
              discountPercent: (r['discount_percent'] as num).toDouble(),
            )
          : Service(
              name: r['sname'] as String,
              price: (r['sprice'] as num).toDouble(),
            );

      return Ticket(
          resident: resident, service: service, date: r['date'] as String);
    }).toList();
  }

  // ----- Export DB -> JSON file -----
  Future<void> exportDbToFile(String path) async {
    final services = await getAllServices();
    final tickets = await getAllTickets();
    final map = {
      'services': services.map((s) => s.toJson()).toList(),
      'tickets': tickets.map((t) => t.toJson()).toList(),
    };
    await File(path).writeAsString(jsonEncode(map), flush: true);
  }

  // ----- Import JSON file -> DB -----
  Future<void> importFileToDb(String path) async {
    final file = File(path);
    if (!file.existsSync()) throw Exception('Файл не найден');
    final parsed =
        jsonDecode(await file.readAsString()) as Map<String, dynamic>;

    if (parsed['services'] != null) {
      for (final e in parsed['services'] as List) {
        final m = Map<String, dynamic>.from(e as Map);
        final s = (m['type'] == 'benefit')
            ? BenefitService.fromJson(m)
            : Service.fromJson(m);

        // no duplicates by name+price
        final db = _db!;
        final exists = await db.query(
          'services',
          where: 'name = ? AND price = ?',
          whereArgs: [s.name, s.price],
          limit: 1,
        );
        if (exists.isEmpty) {
          await insertService(s);
        }
      }
    }

    if (parsed['tickets'] != null) {
      for (final e in parsed['tickets'] as List) {
        final t = Ticket.fromJson(Map<String, dynamic>.from(e as Map));
        await insertTicket(t); // внутри есть проверка дубликатов
      }
    }
  }

  bool get isInitialized => _db != null;
  String get dbPath => _dbPath;
}
